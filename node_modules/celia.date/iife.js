/*
 * celia.date.js v1.0.0
 * (c) 2018-2019 Jesse Feng
 * Released under the MIT License.
 */
var celiaDate = (function (exports) {
  'use strict';

  /*
   * celia.js v6.0.3
   * (c) 2018-2019 Jesse Feng
   * Released under the MIT License.
   */

  function isObject (value) {
    return value !== null && typeof value === 'object';
  }

  var isObject_1 = isObject;

  /*
   * celia.js v6.0.3
   * (c) 2018-2019 Jesse Feng
   * Released under the MIT License.
   */

  function bindContext (iterator, context) {
    return context ? iterator.bind(context) : iterator;
  }

  var _bindContext = bindContext;

  /*
   * celia.js v6.0.3
   * (c) 2018-2019 Jesse Feng
   * Released under the MIT License.
   */

  var hasOwnProperty = Object.prototype.hasOwnProperty;
  function hasOwn (obj, key) {
    return hasOwnProperty.call(obj, key);
  }

  var hasOwn_1 = hasOwn;

  function forOwn (value, iterator, context) {
    iterator = _bindContext(iterator, context);
    // const keys = Object.keys(value);
    // const len = keys.length;
    // for (let i = 0, key; i < len; i++) {
    //   key = keys[i];
    //   i = iterator(value[key], key, value) === false ? len : i;
    // }
    for (var key in value) {
      if (hasOwn_1(value, key) && iterator(value[key], key, value) === false) {
        break;
      }
    }
  }

  var _forOwn = forOwn;

  /*
   * celia.js v6.0.3
   * (c) 2018-2019 Jesse Feng
   * Released under the MIT License.
   */

  function isNil (value) {
    /* eslint eqeqeq: 0 */
    return value == null;
  }

  var isNil_1 = isNil;

  /**
   * 将数组解析成date
   * @param {Array} arr
   * @param {Boolean|undefined} isUTC
   */
  function parseArray (arr, isUTC) {
    var date = isUTC ?
      new Date(Date.UTC(
        arr[0],
        arr[1] || 0,
        isNil_1(arr[2]) ? 1 : arr[2],
        arr[3] || 0,
        arr[4] || 0,
        arr[5] || 0,
        arr[6] || 0
      )) : new Date(
        arr[0],
        arr[1] || 0,
        isNil_1(arr[2]) ? 1 : arr[2],
        arr[3] || 0,
        arr[4] || 0,
        arr[5] || 0,
        arr[6] || 0
      );
    return date;
  }

  /*
   * celia.js v6.0.3
   * (c) 2018-2019 Jesse Feng
   * Released under the MIT License.
   */

  function loop (arr, start, end, callback) {
    for (; start < end; start++) {
      callback(arr[start], start, arr);
    }
  }

  var _loop = loop;

  var TIMEZONE_OFFSET = (new Date()).getTimezoneOffset();
  var MS_OF_SECOND = 1000;
  var MS_OF_MINUTE = 60000;
  var MS_OF_HOUR = 3600000;
  var MS_OF_DAY = 86400000;

  var dateProto = Date.prototype;
  /* eslint no-extend-native: 0 */
  if (!dateProto.setDay) {
    dateProto.setDay = function (val) {
      var day = this.getDay();
      if (val !== day) {
        this.setTime(+this + ((val - day) * MS_OF_DAY));
      }
    };
  }

  var UNITS = {};
  var fns = {};

  function setter(longer, method, alias) {
    fns[longer] = fns[alias || longer] = function (date, val) {
      if (isNil_1(val)) {
        return date[("get" + method)]();
      } else {
        date[("set" + method)](val);
        return date;
      }
    };
  }
  function mapping(key) {
    _loop(arguments, 0, arguments.length, function (arg) {
      UNITS[arg] = key;
    });
    UNITS[key] = key;
  }

  var YEAR = 'year';
  var MONTH = 'month';
  var DATE = 'date';
  var DAY = 'day';
  var HOUR = 'hour';
  var MINUTE = 'minute';
  var SECOND = 'second';
  var MILLISECOND = 'millisecond';
  var TIME = 'time';

  setter(YEAR, 'FullYear');
  setter(MONTH, 'Month');
  setter(DATE, 'Date');
  setter(DAY, 'Day', 'days');
  setter(HOUR, 'Hours', 'hours');
  setter(MINUTE, 'Minutes', 'minutes');
  setter(SECOND, 'Seconds', 'seconds');
  setter(MILLISECOND, 'Milliseconds', 'milliseconds');
  setter(TIME, 'Time');

  mapping(YEAR, 'Y');
  mapping(MONTH, 'M');
  mapping(DATE, 'D');
  mapping(DAY, 'days', 'd');
  mapping(HOUR, 'hours', 'h');
  mapping(MINUTE, 'minutes', 'm');
  mapping(SECOND, 'seconds', 's');
  mapping(MILLISECOND, 'milliseconds', 'ms');
  mapping(TIME, 't');

  function normalize(u, defaultValue) {
    return UNITS[u] || defaultValue;
  }

  function getIndex(unit) {
    unit = normalize(unit, MILLISECOND);
    switch (unit) {
      case YEAR:
        return 0;
      case MONTH:
        return 1;
      case DAY:
        return 2;
      case HOUR:
        return 3;
      case MINUTE:
        return 4;
      case SECOND:
        return 5;
      case MILLISECOND:
        return 6;
    }
  }

  function add (date, num, unit) {
    var arr = [
      date.getFullYear(),
      date.getMonth(),
      date.getDate(),
      date.getHours(),
      date.getMinutes(),
      date.getSeconds(),
      date.getMilliseconds()
    ];
    if (isObject_1(num)) {
      _forOwn(num, function (val, key) {
        arr[getIndex(key)] += val;
      });
    } else {
      arr[getIndex(unit)] += num;
    }
    date.setTime(+parseArray(arr));
    return date;
  }

  function clone (date) {
    return new Date(+date);
  }

  /*
   * celia.js v6.0.3
   * (c) 2018-2019 Jesse Feng
   * Released under the MIT License.
   */

  function _repeat (start, end, callback) {
    for (; start < end; start++) {
      callback(start, end);
    }
  }

  var _repeat_1 = _repeat;

  /*
   * celia.js v6.0.3
   * (c) 2018-2019 Jesse Feng
   * Released under the MIT License.
   */

  function isUndefined (value) {
    return typeof value === 'undefined';
  }

  var isUndefined_1 = isUndefined;

  function isLeapYear (date) {
    var year = date.getFullYear();
    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
  }

  var arr = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var arr2 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

  function daysInYear(date) {
    return isLeapYear(date) ? arr2 : arr;
  }

  function dayOfYear (date, month) {
    return daysInYear(date)[month];
  }

  function dayOfYear$1 (date, val) {
    var arr = daysInYear(date);
    var month = date.getMonth();
    var count = 0;
    _repeat_1(0, month, function (i) {
      count += arr[i];
    });
    count += date.getDate();
    if (isUndefined_1(val)) {
      return count;
    } else {
      date.setTime(+date + ((val - count) * MS_OF_DAY));
      return date;
    }
  }

  function daysInMonth (date) {
    return dayOfYear(date, date.getMonth());
  }

  /*
   * celia.js v6.0.3
   * (c) 2018-2019 Jesse Feng
   * Released under the MIT License.
   */

  function isString (value) {
    return typeof value === 'string';
  }

  var isString_1 = isString;

  function forSlice (value, start, end, iterator, context) {
    iterator = _bindContext(iterator, context);
    for (var i = start; i < end; i++) {
      i = iterator(value[i], i, value) === false ? end : i;
    }
  }

  var _forSlice = forSlice;

  function forEach (value, iterator, context) {
    _forSlice(value, 0, value.length, iterator, context);
  }

  var _forEach = forEach;

  /*
   * celia.js v6.0.3
   * (c) 2018-2019 Jesse Feng
   * Released under the MIT License.
   */

  function isNumber (value) {
    return typeof value === 'number';
  }

  var isNumber_1 = isNumber;

  /*
   * celia.js v6.0.3
   * (c) 2018-2019 Jesse Feng
   * Released under the MIT License.
   */

  // import toString from './_internal/_toString';

  function isDate (value) {
    // return toString(value) === '[object Date]';
    return value instanceof Date;
  }

  var isDate_1 = isDate;

  var ASP_NET_JSON_REGEX = /^\/?Date\((-?\d+)/i;

  var BASIC_ISO_REGEX = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)\s*([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

  var DATES_REGEX = [
    ['YYYY-MM-DD', /(\d{4})-(\d\d)-(\d\d)/],
    ['YYYY-MM', /(\d{4})-(\d\d)/, false],
    // ['MM/DD/YYYY', /(\d\d)\/(\d\d)\/(\d{4})/],
    ['YYYYMMDD', /(\d{4})(\d\d)(\d\d)/],
    ['YYYYMM', /(\d{4})(\d\d)/, false],
    ['YYYY', /\d{4}/, false]
  ];

  var EXTENDED_ISO_REGEX = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)\s*([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

  // export const COMPAT_NON_ISO_REGEX = /^\s*((?:\d\d[-/]\d\d|W\d\d[-/]\d|W\d\d|\d\d\d|\d\d)[-/](?:\d{6}|\d{4}))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)\s*([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

  var FORMAT_REGEX = /\[.*?\]|Y{2,4}|y{2,4}|M{1,2}|D{1,2}|d{1,2}|H{1,2}|h{1,2}|m{1,2}|s{1,2}|SSS|Z{1,2}/g;

  var TIMES_REGEX = [
    ['HH:mm:ss.SSSS', /(\d\d):(\d\d):(\d\d)\.(\d+)/],
    ['HH:mm:ss,SSSS', /(\d\d):(\d\d):(\d\d),(\d+)/],
    ['HH:mm:ss', /(\d\d):(\d\d):(\d\d)/],
    ['HH:mm', /(\d\d):(\d\d)/],
    ['HHmmss.SSSS', /(\d\d)(\d\d)(\d\d)\.(\d+)/],
    ['HHmmss,SSSS', /(\d\d)(\d\d)(\d\d),(\d+)/],
    ['HHmmss', /(\d\d)(\d\d)(\d\d)/],
    ['HHmm', /(\d\d)(\d\d)/],
    ['HH', /\d\d/]
  ];

  var TZ_REGEX = /(Z)|[+-](\d\d)(?::?(\d\d))?/;

  /**
   * 智能提取年月日时分秒
   * @param {String} input 时间字符串
   */
  function extractFrom(input) {
    var allowTime, matches;
    var dateArr = [];
    var match = EXTENDED_ISO_REGEX.exec(input) || BASIC_ISO_REGEX.exec(input);
    if (match) {
      // 解析YYYY-MM-DD
      _forEach(DATES_REGEX, function (item, i) {
        if ((matches = item[1].exec(match[1]))) {
          _repeat_1(0, 3, function (i) {
            dateArr[i] = parseInt(matches[i + 1] || 1, 10);
          });
          dateArr[1] -= 1;
          allowTime = item[2] !== false;
          return false;
        }
      });

      // 有可能是这种 +072019-08-06
      if (input.indexOf(dateArr[0])) {
        return input;
      }

      // 解析hh:mm:ss
      matches = null;
      if (match[3]) {
        _forEach(TIMES_REGEX, function (item) {
          if ((matches = item[1].exec(match[3]))) {
            dateArr = dateArr.concat(matches.slice(1).map(function (n) { return parseInt(n, 10); }));
            return false;
          }
        });
      }
      if (!allowTime && matches) {
        return dateArr;
      }
      matches = null;
      // 时区问题
      if (match[4]) {
        matches = TZ_REGEX.exec(match[4]);
        // 时区
        var offset = TIMEZONE_OFFSET;
        // 匹配到+08:00
        if (!matches[1]) {
          dateArr[3] -= matches[2];
          dateArr[4] -= matches[3] || 0;
        }
        // 统一成当前时区
        dateArr[4] -= offset;
      }
      return dateArr;
    } else {
      // 再试一次
      if (input.length === 4 && DATES_REGEX[4][1].test(input)) {
        dateArr = [parseInt(input, 10), 0, 1];
        dateArr.isUTC = true;
        return dateArr;
      }
      return input;
    }
  }

  /**
   * 解析字符串通过给定的字符串模版
   * @param {String|Array} input
   * @param {String} format
   */
  function parseFromFormat(input, format) {
    var len = format.length;
    var arr = [];
    var isUTC = false;
    _repeat_1(0, len, function (i) {
      var ii = input.charAt(i);
      switch (format.charAt(i)) {
        case 'Y':
        case 'y':
          arr[0] = (arr[0] || '') + ii;
          break;
        case 'M':
          arr[1] = (arr[1] || '') + ii;
          break;
        case 'D':
        case 'd':
          arr[2] = (arr[2] || '') + ii;
          break;
        case 'H':
        case 'h':
          arr[3] = (arr[3] || '') + ii;
          break;
        case 'm':
          arr[4] = (arr[4] || '') + ii;
          break;
        case 's':
          arr[5] = (arr[5] || '') + ii;
          break;
        case 'S':
          arr[6] = (arr[6] || '') + ii;
          break;
        case 'Z':
          isUTC = true;
          break;
      }
    });
    // 转成数字
    arr = arr.map(function (item) { return parseInt(item, 10); });
    if (isUTC) {
      var matches;
      // 解析秒后面的时区
      if ((matches = TZ_REGEX.exec(input.slice(format.indexOf('ZZ') > -1 ? -5 : -6)))) {
        // 时区
        var offset = TIMEZONE_OFFSET;
        // 匹配到类似+08:00
        if (!matches[1]) {
          // 如果在东区，需要减去时区
          var eastOrWest = matches[0].charAt(0) === '+' ? 1 : -1;
          arr[3] -= matches[2] * eastOrWest;
          arr[4] -= (matches[3] || 0) * eastOrWest;
        }
        // 统一成当前时区
        arr[4] -= offset;
      } else {
        // 如果按照UTC的模版解析，就不是UTC了
        arr.isUTC = isUTC & input.indexOf('Z') > -1;
      }
    }
    if (!isNil_1(arr[1])) {
      arr[1] -= 1;
    }
    return arr;
  }

  /**
   * 解析字符串或者数组成date
   * @param {String|Array} input
   * @param {String|Boolean|undefined} format
   * @param {Boolean|undefined} isUTC
   */
  function parseStringOrArray(input, format, isUTC) {
    if (isString_1(input)) {
      var arr;
      if (isString_1(format)) {
        arr = parseFromFormat(input, format);
        return parseArray(arr, arr.isUTC || isUTC);
      } else {
        // 自动判断格式
        arr = extractFrom(input);
        if (arr !== input) {
          return parseArray(arr, arr.isUTC || format === true);
        }
      }
    } else {
      return parseArray(input, format === true);
    }
    var matched = ASP_NET_JSON_REGEX.exec(input);
    return new Date(matched !== null ? +matched[1] : input);
  }

  function parse (input, format, isUTC) {
    if (isNil_1(input)) {
      input = new Date();
    } else if (input.length) {
      input = parseStringOrArray(input, format, isUTC);
    } else if (isNumber_1(input)) {
      input = new Date(input);
    } else if (isDate_1(input)) {
      input = new Date(+input);
    } else if (input._i && input.isValid()) {
      input = new Date(+input);
    } else {
      // input = [], {}, etc
      input = new Date();
    }
    return input;
  }

  function monthDiff(a, b) {
    var wholeMonthDiff = ((b.getFullYear() - a.getFullYear()) * 12) + (b.getMonth() - a.getMonth());
    var anchor = add(clone(a), wholeMonthDiff, MONTH);
    var anchor2, adjust;

    if (b < anchor) {
      anchor2 = add(clone(a), wholeMonthDiff - 1, MONTH);
      adjust = (b - anchor) / (anchor - anchor2);
    } else {
      anchor2 = add(clone(a), wholeMonthDiff + 1, MONTH);
      adjust = (b - anchor) / (anchor2 - anchor);
    }
    return -(wholeMonthDiff + adjust) || 0;
  }

  function absFloor(number) {
    return number < 0 ? (Math.ceil(number) || 0) : Math.floor(number);
  }

  function diff (date, input, units, asFloat) {
    input = parse(input);
    var output;
    units = normalize(units);

    switch (units) {
      case YEAR:
        output = monthDiff(date, input) / 12;
        break;
      case MONTH:
        output = monthDiff(date, input);
        break;
      // case 'D':
      case DAY:
        output = (date - input) / MS_OF_DAY;
        break;
      case HOUR:
        output = (date - input) / MS_OF_HOUR;
        break;
      case MINUTE:
        output = (date - input) / MS_OF_MINUTE;
        break;
      case SECOND:
        output = (date - input) / MS_OF_SECOND;
        break;
      default:
        output = date - input;
    }

    return asFloat ? output : absFloor(output);
  }

  function startOfTime(date, ms) {
    var input = +date;
    return input - input % ms;
  }

  function startOfDate(date, y, m, d) {
    return +new Date(
      y || date.getFullYear(),
      isNil_1(m) ? date.getMonth() : m,
      d || date.getDate()
    );
  }

  function endOf (date, unit) {
    unit = normalize(unit, MILLISECOND);

    var time = 0;

    switch (unit) {
      case YEAR:
        time = startOfDate(date, date.getFullYear() + 1, 0, 1) - 1;
        break;
      case MONTH:
        time = startOfDate(date, null, date.getMonth() + 1, 1) - 1;
        break;
      case DATE:
      case DAY:
        time = startOfDate(date) + MS_OF_DAY - 1;
        break;
      case HOUR:
        time = startOfTime(date, MS_OF_HOUR) + MS_OF_HOUR - 1;
        break;
      case MINUTE:
        time = startOfTime(date, MS_OF_MINUTE) + MS_OF_MINUTE - 1;
        break;
      case SECOND:
        time = startOfTime(date, MS_OF_SECOND) + MS_OF_SECOND - 1;
        break;
    }

    time && date.setTime(time);

    return date;
  }

  var ZERO = '00';

  function padLeft(val, len) {
    if ( len === void 0 ) len = 2;

    return (ZERO + val).slice(-len);
  }

  function timezone(minutes, together) {
    var prefix;
    if (minutes < 0) {
      prefix = '+';
      minutes = Math.abs(minutes);
    } else {
      prefix = '-';
    }
    return ("" + prefix + (padLeft(Math.floor(minutes / 60))) + (together ? '' : ':') + (padLeft(Math.floor(minutes % 60))));
  }

  function h12(hours) {
    hours = hours || 24;
    return hours > 12 ? hours - 12 : hours;
  }

  function format (date, inputString) {
    if (!inputString || inputString === 'UTC') {
      return date.toISOString();
    }
    return inputString.replace(FORMAT_REGEX, function (matched) {
      switch (matched) {
        case 'YY':
          return String(date.getFullYear()).slice(-2);
        case 'YYYY':
        case 'yyyy':
          return date.getFullYear();
        case 'M':
          return date.getMonth() + 1;
        case 'MM':
          return padLeft(date.getMonth() + 1);
        case 'D':
        case 'd':
          return date.getDate();
        case 'DD':
        case 'dd':
          return padLeft(date.getDate());
        // case 'T':
        //   return ' ';
        case 'H':
          return date.getHours();
        case 'HH':
          return padLeft(date.getHours());
        case 'h':
          return h12(date.getHours());
        case 'hh':
          return padLeft(h12(date.getHours()));
        case 'm':
          return date.getMinutes();
        case 'mm':
          return padLeft(date.getMinutes());
        case 's':
          return date.getSeconds();
        case 'ss':
          return padLeft(date.getSeconds());
        case 'SSS':
          return padLeft(date.getMilliseconds(), 3);
        case 'Z':
          return timezone(TIMEZONE_OFFSET);
        case 'ZZ':
          return timezone(TIMEZONE_OFFSET, true);
        default:
          return matched;
      }
    });
  }

  function get (date, unit) {
    unit = normalize(unit, TIME);
    return fns[unit](date);
  }

  function startOf (date, unit) {
    unit = normalize(unit, MILLISECOND);

    var time = 0;

    switch (unit) {
      case YEAR:
        time = startOfDate(date, null, 0, 1);
        break;
      case MONTH:
        time = startOfDate(date, null, null, 1);
        break;
      case DATE:
      case DAY:
        time = startOfDate(date);
        break;
      case HOUR:
        time = startOfTime(date, MS_OF_HOUR);
        break;
      case MINUTE:
        time = startOfTime(date, MS_OF_MINUTE);
        break;
      case SECOND:
        time = startOfTime(date, MS_OF_SECOND);
        break;
    }

    time && date.setTime(time);

    return date;
  }

  function compare (date, input, units, type) {
    input = parse(input);
    units = normalize(units, MILLISECOND);
    if (units === MILLISECOND) {
      switch (type) {
        case 'before':
          return +date < +input;
        case 'after':
          return +date > +input;
        default:
          return +date === +input;
      }
    } else {
      var inputMs = +input;
      switch (type) {
        case 'before':
          return +endOf(clone(date), units) < inputMs;
        case 'after':
          return +startOf(clone(date), units) > inputMs;
        default:
          return +startOf(clone(date), units) <= inputMs && inputMs <= +endOf(clone(date), units);
      }
    }
  }

  function isAfter (date, input, units) {
    return compare(date, input, units, 'after');
  }

  function isBefore (date, input, units) {
    return compare(date, input, units, 'before');
  }

  function isBetween (date, from, to, units, inclusivity) {
    inclusivity = inclusivity || '()';
    return (inclusivity.charAt(0) === '(' ? isAfter(date, from, units) : !isBefore(date, from, units)) &&
      (inclusivity.charAt(1) === ')' ? isBefore(date, to, units) : !isAfter(date, to, units));
  }

  function isSame (date, input, units) {
    return compare(date, input, units);
  }

  function isSameOrAfter (date, input, units) {
    return !isBefore(date, input, units);
  }

  function isSameOrBefore (date, input, units) {
    return !isAfter(date, input, units);
  }

  function isValid (date) {
    return date.toString() !== 'Invalid Date';
  }

  function set (date, unit, val) {
    unit = normalize(unit);
    unit && fns[unit](date, val);
    return date;
  }

  function subtract (date, num, unit) {
    return add(date, -num, unit);
  }

  exports.add = add;
  exports.clone = clone;
  exports.dayOfYear = dayOfYear$1;
  exports.daysInMonth = daysInMonth;
  exports.diff = diff;
  exports.endOf = endOf;
  exports.format = format;
  exports.get = get;
  exports.isAfter = isAfter;
  exports.isBefore = isBefore;
  exports.isBetween = isBetween;
  exports.isLeapYear = isLeapYear;
  exports.isSame = isSame;
  exports.isSameOrAfter = isSameOrAfter;
  exports.isSameOrBefore = isSameOrBefore;
  exports.isValid = isValid;
  exports.parse = parse;
  exports.set = set;
  exports.startOf = startOf;
  exports.subtract = subtract;

  return exports;

}({}));
