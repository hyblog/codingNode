/*
 * celia.js v6.1.4
 * (c) 2018-2019 Jesse Feng
 * Released under the MIT License.
 */
function append (arr, obj) {
  arr[arr.length] = obj;
  return arr;
}

function isNil (value) {
  /* eslint eqeqeq: 0 */
  return value == null;
}

function loop (arr, start, end, callback) {
  for (; start < end; start++) {
    callback(arr[start], start, arr);
  }
}

function bindContext (iterator, context) {
  return context ? iterator.bind(context) : iterator;
}

// import hasOwn from './hasOwn';

function forOwn (value, iterator, context) {
  iterator = bindContext(iterator, context);
  var keys = Object.keys(value);
  var len = keys.length;
  for (var i = 0, key = (void 0); i < len; i++) {
    key = keys[i];
    iterator(value[key], key, value) === false && (i = len);
  }
  // for (let key in value) {
  //   if (hasOwn(value, key) && iterator(value[key], key, value) === false) {
  //     break;
  //   }
  // }
}

function _assign (target) {
  if (isNil(target)) {
    throw new TypeError('Cannot convert undefined or null to object');
  }
  var to = Object(target);
  loop(arguments, 1, arguments.length, function (nextSource) {
    !isNil(nextSource) && forOwn(nextSource, function (nextVal, nextKey) {
      to[nextKey] = nextVal;
    });
  });
  return to;
}

var isArray = Array.isArray;

function flatten(arr, result, depth) {
  loop(arr, 0, arr.length, function (n) {
    if (depth > 0) {
      if (isArray(n)) {
        flatten(n, result, --depth);
      } else {
        append(result, n);
      }
    } else {
      if (isArray(n)) {
        loop(n, 0, n.length, function (m) {
          append(result, m);
        });
      } else {
        append(result, n);
      }
    }
  });
  return result;
}

function forSlice (value, start, end, iterator, context) {
  iterator = bindContext(iterator, context);
  for (var i = start; i < end; i++) {
    iterator(value[i], i, value) === false && (i = end);
  }
}

function forEach (value, iterator, context) {
  forSlice(value, 0, value.length, iterator, context);
}

function forIn (value, iterator, context) {
  iterator = bindContext(iterator, context);
  for (var key in value) {
    if (iterator(value[key], key) === false) {
      break;
    }  }
}

function forNumber (value, iterator, context) {
  iterator = bindContext(iterator, context);
  for (var i = 0; i < value; i++) {
    iterator(i, i, value) === false && (i = value);
  }
}

function isString (value) {
  return typeof value === 'string';
}

var PROP_NAME_REGEX = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var ESCAPE_CHAR_REGEX = /\\(\\)?/g;
var IS_DEEP_PROP_REGEX = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;

function get (object, path) {
  if (!isString(path) || !IS_DEEP_PROP_REGEX.test(path)) {
    return object[path];
  }

  var part;
  PROP_NAME_REGEX.lastIndex = 0;
  while (!isNil(object) && (part = PROP_NAME_REGEX.exec(path))) {
    var match = part[0];
    var number = part[1];
    var quote = part[2];
    var subString = part[3];
    var prop = quote ? subString.replace(ESCAPE_CHAR_REGEX, '$1') : (number || match);
    object = object[prop];
  }
  return object;
}

function isNumber (value) {
  return typeof value === 'number';
}

function _isInteger (value) {
  return isNumber(value) &&
    isFinite(value) &&
    (value >> 0) === value;
}

function map (method, elems, callback, context) {
  var ret = [];
  var cb = bindContext(callback, context);
  method(elems, function (elem, key) {
    elem = cb(elem, key);
    if (!isNil(elem)) {
      append(ret, elem);
    }
  });
  return ret;
}

function removeAt (elems, index) {
  return elems.splice(index, 1)[0] || null;
}

function remove (elems, value) {
  var index = elems.indexOf(value);
  if (index > -1) {
    return removeAt(elems, index);
  }
  return null;
}

function _repeat (start, end, callback) {
  for (; start < end; start++) {
    callback(start, end);
  }
}

function max(a, b) {
  return a > b ? a : b;
}

function transIndex (fromIndex, length) {
  return fromIndex < 0 ? max(0, length + fromIndex) : fromIndex;
}

function isObject (value) {
  return value !== null && typeof value === 'object';
}

function afterCall (obj, methodName, after) {
  if (isObject(obj)) {
    var old = obj[methodName];

    obj[methodName] = function () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      var ret = old.apply(this, args);
      return after.apply(this, args, ret);
    };
  }
}

function each (value, iterator, context) {
  !isNil(value) && forOwn(value, iterator, context);
}

var isArray$1 = Array.isArray;

function alias (proto, mappings) {
  if (isObject(proto)) {
    each(mappings, function (mapping, key) {
      key = proto[key];
      isArray$1(mapping)
        ? mapping.forEach(function (m) { return (proto[m] = key); })
        : (proto[mapping] = key);
    });
  }
}

function aroundCall (obj, method, around) {
  if (isObject(obj)) {
    var old = obj[method];

    obj[method] = function () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      return around.call(this, old, args);
    };
  }
}

function assert (condition, msg) {
  if (!condition) {
    throw new Error(msg);
  }
}

var assign = Object.assign || _assign;

function assign$1(target, nextSource) {
  var copy;
  !isNil(nextSource) && forOwn(nextSource, function (nextVal, nextKey) {
    copy = target[nextKey];
    isObject(copy) && isObject(nextVal)
      ? assign$1(copy, nextVal)
      : (target[nextKey] = nextVal);
  });
}
function assignDeep (target) {
  if (isNil(target)) {
    throw new TypeError('Cannot convert undefined or null to object');
  }
  var to = Object(target);
  loop(arguments, 1, arguments.length, function (nextSource) {
    assign$1(to, nextSource);
  });
  return to;
}

function beforeCall (obj, methodName, before) {
  if (isObject(obj)) {
    var old = obj[methodName];

    obj[methodName] = function () {
      before.apply(this, arguments);
      return old.apply(this, arguments);
    };
  }
}

var DASH_ALPHA_REGEX = /[-_. ]+([a-z])/g;
var cache = Object.create(null);

function camelize (value) {
  if (isString(value)) {
    var hit = cache[value];
    return hit || (cache[value] = value.replace(DASH_ALPHA_REGEX, function (val, letter) {
      return letter.toUpperCase();
    }));
  }
  return value;
}

var cache$1 = Object.create(null);

function capitalize (value) {
  if (isString(value)) {
    var hit = cache$1[value];
    return hit || (cache$1[value] = value.charAt(0).toUpperCase() + value.slice(1));
  }
  return value;
}

function debounce (fn, wait) {
  var timeout = null;

  function cancel() {
    if (timeout !== null) {
      clearTimeout(timeout);
      timeout = null;
    }
  }

  function debounce() {
    cancel();
    timeout = setTimeout(fn, wait);
  }

  debounce.cancel = cancel;
  return debounce;
}

function isFunction (value) {
  return typeof value === 'function';
}

function isArrayLike (value) {
  return !isNil(value) && isNumber(value.length) && !isFunction(value);
}

function each$1 (value, cb, context) {
  if (isArrayLike(value)) {
    forEach(value, cb, context);
  } else if (isNumber(value)) {
    forNumber(value, cb, context);
  } else if (!isNil(value)) {
    forOwn(value, cb, context);
  }
}

function flatten$1 (arr, depth) {
  if (arr) {
    return flatten(arr, [], depth || 1);
  }
  return [];
}

function flattenDeep (arr) {
  return flatten$1(arr, Number.MAX_VALUE);
}

function forEach$1 (arr, cb, ctx) {
  if (arr) {
    forSlice(arr, 0, arr.length, cb, ctx);
  }
}

function forIn$1 (value, iterator, context) {
  !isNil(value) && forIn(value, iterator, context);
}

function forSlice$1 (value, start, end, iterator, context) {
  if (value) {
    var len = value.length;
    if (isFunction(start)) { // forEach like
      context = end;
      iterator = start;
      end = len;
      start = 0;
    } else if (isFunction(end)) {
      context = iterator;
      iterator = end;
      end = len;
    }
    // 如果是负数，就需要转成长度对应的正数
    start = transIndex(start, len);
    end = transIndex(end, len);

    forSlice(value, start, end, iterator, context);
  }
}

var BY_INDEX = /\{\s*(\d+)\s*\}/g;
var BY_KEY = /\{\s*(\w+)\s*\}/g;

function formatString (val, arg) {
  var arguments$1 = arguments;


  if (val && !isNil(arg)) {
    var regexp = BY_KEY;
    if (!isObject(arg)) {
      var len = arguments.length;
      arg = [];

      while (--len) {
        arg[len - 1] = arguments$1[len];
      }

      regexp = BY_INDEX;
    }
    val = val.replace(regexp, function (str, index) {
      var newVal = arg[index];
      return isNil(newVal) ? str : newVal;
    });
  }
  return val;
}

function get$1 (object, path, defaultValue) {
  var result = isNil(object) ? undefined : get(object, path);
  return result === undefined ? defaultValue : result;
}

var UID_PROPERTY = 'celia_uid_' + ((Math.random() * 1e9) >>> 0);
var uidCounter = 0;

function getUid (obj) {
  return obj[UID_PROPERTY] || (++uidCounter, Object.defineProperty(obj, UID_PROPERTY, {
    configurable: true,
    value: uidCounter
  }), uidCounter);
}

function getEasyHash (value) {
  return isObject(value)
    ? 'o' + getUid(value)
    : (typeof value)[0] + value;
}

var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn (obj, key) {
  return hasOwnProperty.call(obj, key);
}

var PROTOCOL = /^([a-z][a-z\d+\-.]*:)?\/\//i;

function isAbsoluteURL (url) {
  return PROTOCOL.test(url);
}

var toString = Object.prototype.toString;

function toString$1 (value) {
  return toString.call(value);
}

function isAsyncFunction (value) {
  return toString$1(value) === '[object AsyncFunction]';
}

function isBoolean (value) {
  return typeof value === 'boolean';
}

// import toString from './_internal/_toString';

function isDate (value) {
  // return toString(value) === '[object Date]';
  return value instanceof Date;
}

var falseLike = {
  false: true,
  null: true,
  undefined: true,
  0: true,
  NaN: true,
  '': true
};
function isFalsy (bool) {
  return !!falseLike[bool];
}

var isInteger = Number.isInteger || _isInteger;

function isPlainObject (value) {
  return !isNil(value) && toString$1(value) === '[object Object]';
}

function isPromiseLike (value) {
  return !!value &&
    isFunction(value.then) &&
    isFunction(value.catch);
}

// import toString from './_internal/_toString';

function isRegExp (value) {
  // return toString(value) === '[object RegExp]';
  return value instanceof RegExp;
}

function isUndefined (value) {
  return typeof value === 'undefined';
}

function isWindow (elem) {
  return !!elem && elem === elem.window;
}

function joinPath (basePath) {
  var len = arguments.length;
  if (!len || isNil(basePath)) {
    return '.';
  }

  var str = '';

  loop(arguments, 1, len, function (arg) {
    if (arg) {
      str += '/';
      str += arg;
    }
  });

  if (str) {
    basePath = basePath.replace(/\/+$/, '') + str.replace(/\/+/g, '/');
  }
  return basePath;
}

function copy(value) {
  return isObject(value)
    ? assign({}, value)
    : value;
}

var isArray$2 = Array.isArray;
function copyDeep(value) {
  var target = value;
  if (isArray$2(value)) {
    target = [];
    value.forEach(function (val, i) {
      target[i] = copyDeep(val);
    });
  } else if (isObject(value)) {
    target = {};
    forOwn(value, function (val, key) {
      target[key] = copyDeep(val);
    });
  }
  return target;
}

function looseClone (value, deep) {
  return deep ? copyDeep(value) : copy(value);
}

var isArray$3 = Array.isArray;
function looseEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (isObject(a) && isObject(b)) {
    if (isArray$3(a) && isArray$3(b)) { // 判断是否是数组
      return a.length === b.length && a.every(function (e, i) {
        return looseEqual(e, b[i]);
      });
    } else if (isDate(a) && isDate(b)) { // 判断日期
      return +a === +b;
    } else if (isRegExp(a) && isRegExp(b)) { // 正则
      return a.toString() === b.toString();
    } else { // 对象
      var keysA = Object.keys(a);
      var keysB = Object.keys(b);
      return keysA.length === keysB.length && keysA.every(function (key) {
        return looseEqual(a[key], b[key]);
      });
    }
  }
  return false;
}

function map$1 (elems, callback, context) {
  return map(each$1, elems, callback, context);
}

function mapObject (elems, callback, context) {
  var ret = {};
  var cb = bindContext(callback, context);
  each(elems, function (elem, key) {
    elem = cb(elem, key);
    !isNil(elem) && (ret[key] = elem);
  });
  return ret;
}

function noop() { }

var isArray$4 = Array.isArray;
function remove$1 (elems, value) {
  if (isArray$4(elems)) {
    return remove(elems, value);
  }
  return null;
}

var isArray$5 = Array.isArray;
function removeAt$1 (elems, index) {
  if (isArray$5(elems)) {
    return removeAt(elems, index);
  }
  return null;
}

function set (object, path, value) {
  if (!isNil(object)) {
    if (!isString(path) || !IS_DEEP_PROP_REGEX.test(path)) {
      object[path] = value;
      return;
    }

    var part;
    var queue = [];
    var i = 0;
    var key;

    PROP_NAME_REGEX.lastIndex = 0;
    while ((part = PROP_NAME_REGEX.exec(path))) {
      var match = part[0];
      var number = part[1];
      var quote = part[2];
      var subString = part[3];
      var obj = (void 0);
      if (quote) {
        key = subString.replace(ESCAPE_CHAR_REGEX, '$1');
        obj = object[key];
        if (isNil(obj)) {
          obj = object[key] = {};
        }
      } else if (number) {
        obj = object[key = number];
        if (isNil(obj)) {
          obj = object[number] = [];
        }
      } else {
        obj = object[key = match];
        if (isNil(obj)) {
          obj = object[match] = {};
        }
      }
      object = obj;
      queue[i++] = obj;
    }

    object = queue[i - 2];
    object[key] = value;
  }
}

function sleep (ms) {
  return new Promise(function (resolve) {
    setTimeout(resolve, ms);
  });
}

function transform(value, iterater, accumulator) {
  each$1(value, function (val, index, object) {
    return iterater(accumulator, val, index, object);
  });
  return accumulator;
}

var RAW_DATA_TYPES = {};
'Boolean,Number,String,Function,AsyncFunction,Array,Date,RegExp,Object,Error,Symbol'.split(',').forEach(function (name) {
  RAW_DATA_TYPES[("[object " + name + "]")] = name.toLowerCase();
});

function type (value) {
  if (isNil(value)) {
    return value + '';
  }
  return (isObject(value) || isFunction(value)) ? (RAW_DATA_TYPES[toString$1(value)] || 'object') : typeof value;
}

export { append as _append, _assign, bindContext as _bindContext, flatten as _flatten, forEach as _forEach, forIn as _forIn, forNumber as _forNumber, forOwn as _forOwn, forSlice as _forSlice, get as _get, _isInteger, loop as _loop, map as _map, remove as _remove, removeAt as _removeAt, _repeat, transIndex as _transIndex, afterCall, alias, aroundCall, assert, assign, assignDeep, beforeCall, camelize, capitalize, debounce, each$1 as each, flatten$1 as flatten, flattenDeep, forEach$1 as forEach, forIn$1 as forIn, each as forOwn, forSlice$1 as forSlice, formatString, get$1 as get, getEasyHash, getUid, hasOwn, isAbsoluteURL, isArrayLike, isAsyncFunction, isBoolean, isDate, isFalsy, isFunction, isInteger, isNil, isNumber, isObject, isPlainObject, isPromiseLike, isRegExp, isString, isUndefined, isWindow, joinPath, looseClone, looseEqual, map$1 as map, mapObject, noop, remove$1 as remove, removeAt$1 as removeAt, set, sleep, toString$1 as toString, transform, type };
