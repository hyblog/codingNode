/*
 * celia.js v6.1.4
 * (c) 2018-2019 Jesse Feng
 * Released under the MIT License.
 */
define(['exports'], function (exports) { 'use strict';

  function append (arr, obj) {
    arr[arr.length] = obj;
    return arr;
  }

  function isNil (value) {
    /* eslint eqeqeq: 0 */
    return value == null;
  }

  function loop (arr, start, end, callback) {
    for (; start < end; start++) {
      callback(arr[start], start, arr);
    }
  }

  function bindContext (iterator, context) {
    return context ? iterator.bind(context) : iterator;
  }

  // import hasOwn from './hasOwn';

  function forOwn (value, iterator, context) {
    iterator = bindContext(iterator, context);
    var keys = Object.keys(value);
    var len = keys.length;
    for (var i = 0, key = (void 0); i < len; i++) {
      key = keys[i];
      iterator(value[key], key, value) === false && (i = len);
    }
    // for (let key in value) {
    //   if (hasOwn(value, key) && iterator(value[key], key, value) === false) {
    //     break;
    //   }
    // }
  }

  function _assign (target) {
    if (isNil(target)) {
      throw new TypeError('Cannot convert undefined or null to object');
    }
    var to = Object(target);
    loop(arguments, 1, arguments.length, function (nextSource) {
      !isNil(nextSource) && forOwn(nextSource, function (nextVal, nextKey) {
        to[nextKey] = nextVal;
      });
    });
    return to;
  }

  var isArray = Array.isArray;

  function flatten(arr, result, depth) {
    loop(arr, 0, arr.length, function (n) {
      if (depth > 0) {
        if (isArray(n)) {
          flatten(n, result, --depth);
        } else {
          append(result, n);
        }
      } else {
        if (isArray(n)) {
          loop(n, 0, n.length, function (m) {
            append(result, m);
          });
        } else {
          append(result, n);
        }
      }
    });
    return result;
  }

  function forSlice (value, start, end, iterator, context) {
    iterator = bindContext(iterator, context);
    for (var i = start; i < end; i++) {
      iterator(value[i], i, value) === false && (i = end);
    }
  }

  function forEach (value, iterator, context) {
    forSlice(value, 0, value.length, iterator, context);
  }

  function forIn (value, iterator, context) {
    iterator = bindContext(iterator, context);
    for (var key in value) {
      if (iterator(value[key], key) === false) {
        break;
      }  }
  }

  function forNumber (value, iterator, context) {
    iterator = bindContext(iterator, context);
    for (var i = 0; i < value; i++) {
      iterator(i, i, value) === false && (i = value);
    }
  }

  function isString (value) {
    return typeof value === 'string';
  }

  var PROP_NAME_REGEX = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var ESCAPE_CHAR_REGEX = /\\(\\)?/g;
  var IS_DEEP_PROP_REGEX = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;

  function get (object, path) {
    if (!isString(path) || !IS_DEEP_PROP_REGEX.test(path)) {
      return object[path];
    }

    var part;
    PROP_NAME_REGEX.lastIndex = 0;
    while (!isNil(object) && (part = PROP_NAME_REGEX.exec(path))) {
      var match = part[0];
      var number = part[1];
      var quote = part[2];
      var subString = part[3];
      var prop = quote ? subString.replace(ESCAPE_CHAR_REGEX, '$1') : (number || match);
      object = object[prop];
    }
    return object;
  }

  function isNumber (value) {
    return typeof value === 'number';
  }

  function _isInteger (value) {
    return isNumber(value) &&
      isFinite(value) &&
      (value >> 0) === value;
  }

  function map (method, elems, callback, context) {
    var ret = [];
    var cb = bindContext(callback, context);
    method(elems, function (elem, key) {
      elem = cb(elem, key);
      if (!isNil(elem)) {
        append(ret, elem);
      }
    });
    return ret;
  }

  function removeAt (elems, index) {
    return elems.splice(index, 1)[0] || null;
  }

  function remove (elems, value) {
    var index = elems.indexOf(value);
    if (index > -1) {
      return removeAt(elems, index);
    }
    return null;
  }

  function _repeat (start, end, callback) {
    for (; start < end; start++) {
      callback(start, end);
    }
  }

  function max(a, b) {
    return a > b ? a : b;
  }

  function transIndex (fromIndex, length) {
    return fromIndex < 0 ? max(0, length + fromIndex) : fromIndex;
  }

  function isObject (value) {
    return value !== null && typeof value === 'object';
  }

  function afterCall (obj, methodName, after) {
    if (isObject(obj)) {
      var old = obj[methodName];

      obj[methodName] = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var ret = old.apply(this, args);
        return after.apply(this, args, ret);
      };
    }
  }

  function each (value, iterator, context) {
    !isNil(value) && forOwn(value, iterator, context);
  }

  var isArray$1 = Array.isArray;

  function alias (proto, mappings) {
    if (isObject(proto)) {
      each(mappings, function (mapping, key) {
        key = proto[key];
        isArray$1(mapping)
          ? mapping.forEach(function (m) { return (proto[m] = key); })
          : (proto[mapping] = key);
      });
    }
  }

  function aroundCall (obj, method, around) {
    if (isObject(obj)) {
      var old = obj[method];

      obj[method] = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return around.call(this, old, args);
      };
    }
  }

  function assert (condition, msg) {
    if (!condition) {
      throw new Error(msg);
    }
  }

  var assign = Object.assign || _assign;

  function assign$1(target, nextSource) {
    var copy;
    !isNil(nextSource) && forOwn(nextSource, function (nextVal, nextKey) {
      copy = target[nextKey];
      isObject(copy) && isObject(nextVal)
        ? assign$1(copy, nextVal)
        : (target[nextKey] = nextVal);
    });
  }
  function assignDeep (target) {
    if (isNil(target)) {
      throw new TypeError('Cannot convert undefined or null to object');
    }
    var to = Object(target);
    loop(arguments, 1, arguments.length, function (nextSource) {
      assign$1(to, nextSource);
    });
    return to;
  }

  function beforeCall (obj, methodName, before) {
    if (isObject(obj)) {
      var old = obj[methodName];

      obj[methodName] = function () {
        before.apply(this, arguments);
        return old.apply(this, arguments);
      };
    }
  }

  var DASH_ALPHA_REGEX = /[-_. ]+([a-z])/g;
  var cache = Object.create(null);

  function camelize (value) {
    if (isString(value)) {
      var hit = cache[value];
      return hit || (cache[value] = value.replace(DASH_ALPHA_REGEX, function (val, letter) {
        return letter.toUpperCase();
      }));
    }
    return value;
  }

  var cache$1 = Object.create(null);

  function capitalize (value) {
    if (isString(value)) {
      var hit = cache$1[value];
      return hit || (cache$1[value] = value.charAt(0).toUpperCase() + value.slice(1));
    }
    return value;
  }

  function debounce (fn, wait) {
    var timeout = null;

    function cancel() {
      if (timeout !== null) {
        clearTimeout(timeout);
        timeout = null;
      }
    }

    function debounce() {
      cancel();
      timeout = setTimeout(fn, wait);
    }

    debounce.cancel = cancel;
    return debounce;
  }

  function isFunction (value) {
    return typeof value === 'function';
  }

  function isArrayLike (value) {
    return !isNil(value) && isNumber(value.length) && !isFunction(value);
  }

  function each$1 (value, cb, context) {
    if (isArrayLike(value)) {
      forEach(value, cb, context);
    } else if (isNumber(value)) {
      forNumber(value, cb, context);
    } else if (!isNil(value)) {
      forOwn(value, cb, context);
    }
  }

  function flatten$1 (arr, depth) {
    if (arr) {
      return flatten(arr, [], depth || 1);
    }
    return [];
  }

  function flattenDeep (arr) {
    return flatten$1(arr, Number.MAX_VALUE);
  }

  function forEach$1 (arr, cb, ctx) {
    if (arr) {
      forSlice(arr, 0, arr.length, cb, ctx);
    }
  }

  function forIn$1 (value, iterator, context) {
    !isNil(value) && forIn(value, iterator, context);
  }

  function forSlice$1 (value, start, end, iterator, context) {
    if (value) {
      var len = value.length;
      if (isFunction(start)) { // forEach like
        context = end;
        iterator = start;
        end = len;
        start = 0;
      } else if (isFunction(end)) {
        context = iterator;
        iterator = end;
        end = len;
      }
      // 如果是负数，就需要转成长度对应的正数
      start = transIndex(start, len);
      end = transIndex(end, len);

      forSlice(value, start, end, iterator, context);
    }
  }

  var BY_INDEX = /\{\s*(\d+)\s*\}/g;
  var BY_KEY = /\{\s*(\w+)\s*\}/g;

  function formatString (val, arg) {
    var arguments$1 = arguments;


    if (val && !isNil(arg)) {
      var regexp = BY_KEY;
      if (!isObject(arg)) {
        var len = arguments.length;
        arg = [];

        while (--len) {
          arg[len - 1] = arguments$1[len];
        }

        regexp = BY_INDEX;
      }
      val = val.replace(regexp, function (str, index) {
        var newVal = arg[index];
        return isNil(newVal) ? str : newVal;
      });
    }
    return val;
  }

  function get$1 (object, path, defaultValue) {
    var result = isNil(object) ? undefined : get(object, path);
    return result === undefined ? defaultValue : result;
  }

  var UID_PROPERTY = 'celia_uid_' + ((Math.random() * 1e9) >>> 0);
  var uidCounter = 0;

  function getUid (obj) {
    return obj[UID_PROPERTY] || (++uidCounter, Object.defineProperty(obj, UID_PROPERTY, {
      configurable: true,
      value: uidCounter
    }), uidCounter);
  }

  function getEasyHash (value) {
    return isObject(value)
      ? 'o' + getUid(value)
      : (typeof value)[0] + value;
  }

  var hasOwnProperty = Object.prototype.hasOwnProperty;
  function hasOwn (obj, key) {
    return hasOwnProperty.call(obj, key);
  }

  var PROTOCOL = /^([a-z][a-z\d+\-.]*:)?\/\//i;

  function isAbsoluteURL (url) {
    return PROTOCOL.test(url);
  }

  var toString = Object.prototype.toString;

  function toString$1 (value) {
    return toString.call(value);
  }

  function isAsyncFunction (value) {
    return toString$1(value) === '[object AsyncFunction]';
  }

  function isBoolean (value) {
    return typeof value === 'boolean';
  }

  // import toString from './_internal/_toString';

  function isDate (value) {
    // return toString(value) === '[object Date]';
    return value instanceof Date;
  }

  var falseLike = {
    false: true,
    null: true,
    undefined: true,
    0: true,
    NaN: true,
    '': true
  };
  function isFalsy (bool) {
    return !!falseLike[bool];
  }

  var isInteger = Number.isInteger || _isInteger;

  function isPlainObject (value) {
    return !isNil(value) && toString$1(value) === '[object Object]';
  }

  function isPromiseLike (value) {
    return !!value &&
      isFunction(value.then) &&
      isFunction(value.catch);
  }

  // import toString from './_internal/_toString';

  function isRegExp (value) {
    // return toString(value) === '[object RegExp]';
    return value instanceof RegExp;
  }

  function isUndefined (value) {
    return typeof value === 'undefined';
  }

  function isWindow (elem) {
    return !!elem && elem === elem.window;
  }

  function joinPath (basePath) {
    var len = arguments.length;
    if (!len || isNil(basePath)) {
      return '.';
    }

    var str = '';

    loop(arguments, 1, len, function (arg) {
      if (arg) {
        str += '/';
        str += arg;
      }
    });

    if (str) {
      basePath = basePath.replace(/\/+$/, '') + str.replace(/\/+/g, '/');
    }
    return basePath;
  }

  function copy(value) {
    return isObject(value)
      ? assign({}, value)
      : value;
  }

  var isArray$2 = Array.isArray;
  function copyDeep(value) {
    var target = value;
    if (isArray$2(value)) {
      target = [];
      value.forEach(function (val, i) {
        target[i] = copyDeep(val);
      });
    } else if (isObject(value)) {
      target = {};
      forOwn(value, function (val, key) {
        target[key] = copyDeep(val);
      });
    }
    return target;
  }

  function looseClone (value, deep) {
    return deep ? copyDeep(value) : copy(value);
  }

  var isArray$3 = Array.isArray;
  function looseEqual(a, b) {
    if (a === b) {
      return true;
    }
    if (isObject(a) && isObject(b)) {
      if (isArray$3(a) && isArray$3(b)) { // 判断是否是数组
        return a.length === b.length && a.every(function (e, i) {
          return looseEqual(e, b[i]);
        });
      } else if (isDate(a) && isDate(b)) { // 判断日期
        return +a === +b;
      } else if (isRegExp(a) && isRegExp(b)) { // 正则
        return a.toString() === b.toString();
      } else { // 对象
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        return keysA.length === keysB.length && keysA.every(function (key) {
          return looseEqual(a[key], b[key]);
        });
      }
    }
    return false;
  }

  function map$1 (elems, callback, context) {
    return map(each$1, elems, callback, context);
  }

  function mapObject (elems, callback, context) {
    var ret = {};
    var cb = bindContext(callback, context);
    each(elems, function (elem, key) {
      elem = cb(elem, key);
      !isNil(elem) && (ret[key] = elem);
    });
    return ret;
  }

  function noop() { }

  var isArray$4 = Array.isArray;
  function remove$1 (elems, value) {
    if (isArray$4(elems)) {
      return remove(elems, value);
    }
    return null;
  }

  var isArray$5 = Array.isArray;
  function removeAt$1 (elems, index) {
    if (isArray$5(elems)) {
      return removeAt(elems, index);
    }
    return null;
  }

  function set (object, path, value) {
    if (!isNil(object)) {
      if (!isString(path) || !IS_DEEP_PROP_REGEX.test(path)) {
        object[path] = value;
        return;
      }

      var part;
      var queue = [];
      var i = 0;
      var key;

      PROP_NAME_REGEX.lastIndex = 0;
      while ((part = PROP_NAME_REGEX.exec(path))) {
        var match = part[0];
        var number = part[1];
        var quote = part[2];
        var subString = part[3];
        var obj = (void 0);
        if (quote) {
          key = subString.replace(ESCAPE_CHAR_REGEX, '$1');
          obj = object[key];
          if (isNil(obj)) {
            obj = object[key] = {};
          }
        } else if (number) {
          obj = object[key = number];
          if (isNil(obj)) {
            obj = object[number] = [];
          }
        } else {
          obj = object[key = match];
          if (isNil(obj)) {
            obj = object[match] = {};
          }
        }
        object = obj;
        queue[i++] = obj;
      }

      object = queue[i - 2];
      object[key] = value;
    }
  }

  function sleep (ms) {
    return new Promise(function (resolve) {
      setTimeout(resolve, ms);
    });
  }

  function transform(value, iterater, accumulator) {
    each$1(value, function (val, index, object) {
      return iterater(accumulator, val, index, object);
    });
    return accumulator;
  }

  var RAW_DATA_TYPES = {};
  'Boolean,Number,String,Function,AsyncFunction,Array,Date,RegExp,Object,Error,Symbol'.split(',').forEach(function (name) {
    RAW_DATA_TYPES[("[object " + name + "]")] = name.toLowerCase();
  });

  function type (value) {
    if (isNil(value)) {
      return value + '';
    }
    return (isObject(value) || isFunction(value)) ? (RAW_DATA_TYPES[toString$1(value)] || 'object') : typeof value;
  }

  exports._append = append;
  exports._assign = _assign;
  exports._bindContext = bindContext;
  exports._flatten = flatten;
  exports._forEach = forEach;
  exports._forIn = forIn;
  exports._forNumber = forNumber;
  exports._forOwn = forOwn;
  exports._forSlice = forSlice;
  exports._get = get;
  exports._isInteger = _isInteger;
  exports._loop = loop;
  exports._map = map;
  exports._remove = remove;
  exports._removeAt = removeAt;
  exports._repeat = _repeat;
  exports._transIndex = transIndex;
  exports.afterCall = afterCall;
  exports.alias = alias;
  exports.aroundCall = aroundCall;
  exports.assert = assert;
  exports.assign = assign;
  exports.assignDeep = assignDeep;
  exports.beforeCall = beforeCall;
  exports.camelize = camelize;
  exports.capitalize = capitalize;
  exports.debounce = debounce;
  exports.each = each$1;
  exports.flatten = flatten$1;
  exports.flattenDeep = flattenDeep;
  exports.forEach = forEach$1;
  exports.forIn = forIn$1;
  exports.forOwn = each;
  exports.forSlice = forSlice$1;
  exports.formatString = formatString;
  exports.get = get$1;
  exports.getEasyHash = getEasyHash;
  exports.getUid = getUid;
  exports.hasOwn = hasOwn;
  exports.isAbsoluteURL = isAbsoluteURL;
  exports.isArrayLike = isArrayLike;
  exports.isAsyncFunction = isAsyncFunction;
  exports.isBoolean = isBoolean;
  exports.isDate = isDate;
  exports.isFalsy = isFalsy;
  exports.isFunction = isFunction;
  exports.isInteger = isInteger;
  exports.isNil = isNil;
  exports.isNumber = isNumber;
  exports.isObject = isObject;
  exports.isPlainObject = isPlainObject;
  exports.isPromiseLike = isPromiseLike;
  exports.isRegExp = isRegExp;
  exports.isString = isString;
  exports.isUndefined = isUndefined;
  exports.isWindow = isWindow;
  exports.joinPath = joinPath;
  exports.looseClone = looseClone;
  exports.looseEqual = looseEqual;
  exports.map = map$1;
  exports.mapObject = mapObject;
  exports.noop = noop;
  exports.remove = remove$1;
  exports.removeAt = removeAt$1;
  exports.set = set;
  exports.sleep = sleep;
  exports.toString = toString$1;
  exports.transform = transform;
  exports.type = type;

});
